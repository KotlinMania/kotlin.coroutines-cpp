#pragma once
// port-lint: source flow/operators/Zip.kt
/**
 * @file Zip.hpp
 * @brief Flow zip and combine operators
 *
 * Transliterated from: kotlinx-coroutines-core/common/src/flow/operators/Zip.kt
 */

#include "kotlinx/coroutines/flow/Flow.hpp"
#include "kotlinx/coroutines/flow/FlowBuilders.hpp"
#include <functional>
#include <memory>
#include <vector>
#include <queue>
#include <mutex>

namespace kotlinx {
namespace coroutines {
namespace flow {

// Alias for the flow builder to avoid shadowing issues with parameters
template<typename T>
inline std::shared_ptr<Flow<T>> make_flow(std::function<void(FlowCollector<T>*)> block) {
    return flow<T>(block);
}

/**
 * Zips values from the current flow (flow1) with other flow (flow2) using provided transform.
 *
 * The resulting flow completes as soon as one of the flows completes and cancels
 * the remaining one.
 *
 * TODO: Implement proper coroutine-based zip with channels
 */
template <typename T1, typename T2, typename R>
std::shared_ptr<Flow<R>> zip(std::shared_ptr<Flow<T1>> flow1, std::shared_ptr<Flow<T2>> flow2, std::function<R(T1, T2)> transform_fn) {
    // TODO: Implement proper concurrent zip using channels
    // For now, collect both flows first (not correct but compiles)
    return make_flow<R>([flow1, flow2, transform_fn](FlowCollector<R>* collector) {
        std::vector<T1> values1;
        std::vector<T2> values2;

        flow1->collect([&values1](T1 value) {
            values1.push_back(value);
        });

        flow2->collect([&values2](T2 value) {
            values2.push_back(value);
        });

        size_t count = std::min(values1.size(), values2.size());
        for (size_t i = 0; i < count; ++i) {
            collector->emit(transform_fn(values1[i], values2[i]));
        }
    });
}

/**
 * Returns a Flow whose values are generated by transform function that process
 * the most recently emitted values by each flow.
 *
 * TODO: Implement combineTransform with proper emission semantics
 */
template <typename T1, typename T2, typename R>
std::shared_ptr<Flow<R>> combine_transform(
    std::shared_ptr<Flow<T1>> flow1,
    std::shared_ptr<Flow<T2>> flow2,
    std::function<void(FlowCollector<R>*, T1, T2)> transform_fn
) {
    // TODO: Implement combineTransform with proper concurrency
    return nullptr;
}

/**
 * Returns a Flow whose values are generated with transform function by combining
 * the most recently emitted values by each flow.
 *
 * 3-way combine.
 *
 * TODO: Implement 3-way combine
 */
template <typename T1, typename T2, typename T3, typename R>
std::shared_ptr<Flow<R>> combine(
    std::shared_ptr<Flow<T1>> f1,
    std::shared_ptr<Flow<T2>> f2,
    std::shared_ptr<Flow<T3>> f3,
    std::function<R(T1, T2, T3)> transform_fn
) {
    // TODO: Implement 3-way combine (requires internal::combine_impl support for N-arity)
    return nullptr;
}

/**
 * Returns a Flow whose values are generated with transform function by combining
 * the most recently emitted values by each flow.
 *
 * 4-way combine.
 *
 * TODO: Implement 4-way combine
 */
template <typename T1, typename T2, typename T3, typename T4, typename R>
std::shared_ptr<Flow<R>> combine(
    std::shared_ptr<Flow<T1>> f1,
    std::shared_ptr<Flow<T2>> f2,
    std::shared_ptr<Flow<T3>> f3,
    std::shared_ptr<Flow<T4>> f4,
    std::function<R(T1, T2, T3, T4)> transform_fn
) {
    // TODO: Implement 4-way combine
    return nullptr;
}

/**
 * Returns a Flow whose values are generated with transform function by combining
 * the most recently emitted values by each flow.
 *
 * Vector-based combine for N flows of the same type.
 *
 * TODO: Implement vector-based combine
 */
template <typename T, typename R>
std::shared_ptr<Flow<R>> combine_all(
    std::vector<std::shared_ptr<Flow<T>>> flows,
    std::function<R(std::vector<T>)> transform_fn
) {
    // TODO: Implement vector-based combine (combineInternal)
    return nullptr;
}

} // namespace flow
} // namespace coroutines
} // namespace kotlinx
