#pragma once
// port-lint: source flow/operators/Zip.kt
/**
 * @file Zip.hpp
 * @brief Flow zip and combine operators
 *
 * Transliterated from: kotlinx-coroutines-core/common/src/flow/operators/Zip.kt
 */

#include "kotlinx/coroutines/flow/Flow.hpp"
#include "kotlinx/coroutines/flow/FlowBuilders.hpp"
#include <functional>
#include <memory>
#include <vector>
#include <queue>
#include <mutex>
#include <optional>
#include <algorithm>

namespace kotlinx {
namespace coroutines {
namespace flow {

// Alias for the flow builder to avoid shadowing issues with parameters
template<typename T>
inline std::shared_ptr<Flow<T>> make_flow(std::function<void(FlowCollector<T>*)> block) {
    return flow<T>(block);
}

/**
 * Zips values from the current flow (flow1) with other flow (flow2) using provided transform.
 *
 * The resulting flow completes as soon as one of the flows completes and cancels
 * the remaining one.
 *
 * It can be demonstrated with the following example:
 * ```cpp
 * auto flow1 = flow_of({1, 2, 3}); // with delay(10)
 * auto flow2 = flow_of({"a", "b", "c", "d"}); // with delay(15)
 * auto zipped = zip(flow1, flow2, [](int i, std::string s) { return std::to_string(i) + s; });
 * // Will produce: "1a", "2b", "3c"
 * ```
 *
 * Transliterated from:
 * public fun <T1, T2, R> Flow<T1>.zip(other: Flow<T2>, transform: suspend (T1, T2) -> R): Flow<R>
 */
template <typename T1, typename T2, typename R>
std::shared_ptr<Flow<R>> zip(std::shared_ptr<Flow<T1>> flow1, std::shared_ptr<Flow<T2>> flow2, std::function<R(T1, T2)> transform_fn) {
    // TODO: Implement proper concurrent zip using channels
    // For now, collect both flows first (not correct but compiles)
    return make_flow<R>([flow1, flow2, transform_fn](FlowCollector<R>* collector) {
        std::vector<T1> values1;
        std::vector<T2> values2;

        flow1->collect([&values1](T1 value) {
            values1.push_back(value);
        });

        flow2->collect([&values2](T2 value) {
            values2.push_back(value);
        });

        size_t count = std::min(values1.size(), values2.size());
        for (size_t i = 0; i < count; ++i) {
            collector->emit(transform_fn(values1[i], values2[i]));
        }
    });
}

// ============================================================================
// Line 27-48: 2-way combine
// ============================================================================

/**
 * Returns a Flow whose values are generated with transform function by combining
 * the most recently emitted values by each flow.
 *
 * It can be demonstrated with the following example:
 * ```cpp
 * auto flow1 = flow_of({1, 2}); // with onEach { delay(10) }
 * auto flow2 = flow_of({"a", "b", "c"}); // with onEach { delay(15) }
 * auto combined = combine(flow1, flow2, [](int i, std::string s) { return std::to_string(i) + s; });
 * // Will produce: "1a", "2a", "2b", "2c"
 * ```
 *
 * This function is a shorthand for `flow.combineTransform(flow2) { a, b -> emit(transform(a, b)) }`.
 *
 * Transliterated from:
 * public fun <T1, T2, R> Flow<T1>.combine(flow: Flow<T2>, transform: suspend (a: T1, b: T2) -> R): Flow<R>
 */
template <typename T1, typename T2, typename R>
std::shared_ptr<Flow<R>> combine(
    std::shared_ptr<Flow<T1>> flow1,
    std::shared_ptr<Flow<T2>> flow2,
    std::function<R(T1, T2)> transform_fn
) {
    // Uses combineInternal with two flows
    // TODO: Implement proper concurrent combine with most-recently-emitted semantics
    // For now, simplified implementation that doesn't have proper concurrency
    return make_flow<R>([flow1, flow2, transform_fn](FlowCollector<R>* collector) {
        std::optional<T1> latest1;
        std::optional<T2> latest2;
        std::mutex mutex;
        
        // This is a simplified sequential implementation
        // Real implementation would use channels for concurrent collection
        std::vector<T1> values1;
        std::vector<T2> values2;

        flow1->collect([&values1](T1 value) {
            values1.push_back(value);
        });

        flow2->collect([&values2](T2 value) {
            values2.push_back(value);
        });

        // Emit combined values as they would be in combine semantics
        // This is a simplification - real combine uses most recent from each
        if (!values1.empty() && !values2.empty()) {
            for (size_t i2 = 0; i2 < values2.size(); ++i2) {
                // Find the latest value1 at this point
                size_t i1 = std::min(i2, values1.size() - 1);
                collector->emit(transform_fn(values1[i1], values2[i2]));
            }
        }
    });
}

/**
 * Returns a Flow whose values are generated by transform function that process
 * the most recently emitted values by each flow.
 *
 * TODO: Implement combineTransform with proper emission semantics
 */
template <typename T1, typename T2, typename R>
std::shared_ptr<Flow<R>> combine_transform(
    std::shared_ptr<Flow<T1>> flow1,
    std::shared_ptr<Flow<T2>> flow2,
    std::function<void(FlowCollector<R>*, T1, T2)> transform_fn
) {
    // TODO: Implement combineTransform with proper concurrency
    return nullptr;
}

/**
 * Returns a Flow whose values are generated with transform function by combining
 * the most recently emitted values by each flow.
 *
 * 3-way combine.
 *
 * TODO: Implement 3-way combine
 */
template <typename T1, typename T2, typename T3, typename R>
std::shared_ptr<Flow<R>> combine(
    std::shared_ptr<Flow<T1>> f1,
    std::shared_ptr<Flow<T2>> f2,
    std::shared_ptr<Flow<T3>> f3,
    std::function<R(T1, T2, T3)> transform_fn
) {
    // TODO: Implement 3-way combine (requires internal::combine_impl support for N-arity)
    return nullptr;
}

/**
 * Returns a Flow whose values are generated with transform function by combining
 * the most recently emitted values by each flow.
 *
 * 4-way combine.
 *
 * TODO: Implement 4-way combine
 */
template <typename T1, typename T2, typename T3, typename T4, typename R>
std::shared_ptr<Flow<R>> combine(
    std::shared_ptr<Flow<T1>> f1,
    std::shared_ptr<Flow<T2>> f2,
    std::shared_ptr<Flow<T3>> f3,
    std::shared_ptr<Flow<T4>> f4,
    std::function<R(T1, T2, T3, T4)> transform_fn
) {
    // TODO: Implement 4-way combine
    return nullptr;
}

/**
 * Returns a Flow whose values are generated with transform function by combining
 * the most recently emitted values by each flow.
 *
 * Vector-based combine for N flows of the same type.
 *
 * TODO: Implement vector-based combine
 */
template <typename T, typename R>
std::shared_ptr<Flow<R>> combine_all(
    std::vector<std::shared_ptr<Flow<T>>> flows,
    std::function<R(std::vector<T>)> transform_fn
) {
    // TODO: Implement vector-based combine (combineInternal)
    return nullptr;
}

} // namespace flow
} // namespace coroutines
} // namespace kotlinx
