# KotlinxCoroutineTransform.cmake
#
# CMake module for transforming C++ coroutines with suspend points into
# computed-goto state machines matching Kotlin/Native's LLVM IR pattern.
#
# Usage:
#   include(KotlinxCoroutineTransform)
#   kxs_enable_coroutine_transform(target)
#
# This module provides:
#   kxs_enable_coroutine_transform(<target>) - Enable IR transformation for a target
#   kxs_transform_ir(<input> <output>)       - Transform a single .ll file
#
# The transformation:
#   1. Finds calls to __kxs_suspend_point(i32 <id>)
#   2. Replaces them with computed-goto dispatch (indirectbr + blockaddress)
#   3. Generates resume labels for each suspend point
#
# This matches Kotlin/Native's coroutine lowering pattern exactly.

cmake_minimum_required(VERSION 3.18)

#[============================================================================[
  Internal: Transform LLVM IR text to inject coroutine dispatch
#]============================================================================]
function(_kxs_transform_ir_impl INPUT_FILE OUTPUT_FILE)
    # Read the IR file
    file(READ "${INPUT_FILE}" IR_CONTENT)

    # Find all suspend point calls
    string(REGEX MATCHALL "call void @__kxs_suspend_point\\(i32[^)]*\\)"
           SUSPEND_CALLS "${IR_CONTENT}")

    list(LENGTH SUSPEND_CALLS NUM_SUSPEND_POINTS)

    if(NUM_SUSPEND_POINTS EQUAL 0)
        # No transformation needed - copy as-is
        file(WRITE "${OUTPUT_FILE}" "${IR_CONTENT}")
        return()
    endif()

    # Find functions containing suspend points
    string(REGEX MATCHALL "define [^\n]+ @([A-Za-z_][A-Za-z0-9_]*)[^\n]*\\{[^}]*__kxs_suspend_point[^}]*\\}"
           FUNCS_WITH_SUSPEND "${IR_CONTENT}")

    set(TRANSFORMED_IR "${IR_CONTENT}")

    # Process each suspend call
    set(RESUME_LABELS "")
    set(SUSPEND_IDX 0)

    foreach(SUSPEND_CALL ${SUSPEND_CALLS})
        # Extract suspend point ID
        string(REGEX MATCH "i32[^0-9]*([0-9]+)" ID_MATCH "${SUSPEND_CALL}")
        string(REGEX MATCH "[0-9]+" SUSPEND_ID "${ID_MATCH}")

        # Generate resume label
        set(RESUME_LABEL "kxs.resume.${SUSPEND_IDX}")
        list(APPEND RESUME_LABELS "${RESUME_LABEL}")

        # Build the replacement IR:
        # Before: call void @__kxs_suspend_point(i32 N)
        # After:
        #   store ptr blockaddress(@func, %kxs.resume.N), ptr %kxs.label.ptr
        #   ; suspension check would go here
        #   br label %kxs.resume.N
        # kxs.resume.N:

        set(REPLACEMENT_IR [[
  ; KXS suspend point ${SUSPEND_ID}
  ; TODO: store blockaddress to coroutine label field
  ; TODO: check if actually suspended, return COROUTINE_SUSPENDED
  br label %${RESUME_LABEL}

${RESUME_LABEL}:
  ; KXS resume point ${SUSPEND_ID}]])

        # Substitute variables in replacement
        string(REPLACE "\${SUSPEND_ID}" "${SUSPEND_ID}" REPLACEMENT_IR "${REPLACEMENT_IR}")
        string(REPLACE "\${RESUME_LABEL}" "${RESUME_LABEL}" REPLACEMENT_IR "${REPLACEMENT_IR}")

        string(REPLACE "${SUSPEND_CALL}" "${REPLACEMENT_IR}" TRANSFORMED_IR "${TRANSFORMED_IR}")

        math(EXPR SUSPEND_IDX "${SUSPEND_IDX} + 1")
    endforeach()

    # Generate dispatch block labels list for indirectbr
    set(LABEL_LIST "")
    foreach(LABEL ${RESUME_LABELS})
        if(LABEL_LIST)
            string(APPEND LABEL_LIST ", ")
        endif()
        string(APPEND LABEL_LIST "label %${LABEL}")
    endforeach()

    # Insert entry dispatch at function start
    # Pattern: After "define ... @funcname(...) ... {"
    set(ENTRY_DISPATCH [[

kxs.entry:
  ; KXS coroutine entry dispatch
  ; Load saved label from coroutine struct
  ; %kxs.saved.label = load ptr, ptr %0  ; assuming arg0 is coroutine ptr
  ; %kxs.is.first = icmp eq ptr %kxs.saved.label, null
  ; br i1 %kxs.is.first, label %kxs.start, label %kxs.dispatch
  br label %kxs.start

; kxs.dispatch:
;   indirectbr ptr %kxs.saved.label, [${LABEL_LIST}]

kxs.start:]])

    string(REPLACE "\${LABEL_LIST}" "${LABEL_LIST}" ENTRY_DISPATCH "${ENTRY_DISPATCH}")

    # Insert after function opening brace
    # This is a simplified insertion - real impl needs smarter parsing
    string(REGEX REPLACE
        "(define [^\n]+\\{)\n"
        "\\1\n${ENTRY_DISPATCH}\n"
        TRANSFORMED_IR "${TRANSFORMED_IR}")

    # Add header comment
    set(HEADER [[
; ============================================================================
; KXS-TRANSFORMED IR
; Suspend points: ${NUM_SUSPEND_POINTS}
; Resume labels: ${RESUME_LABELS}
; Generated by KotlinxCoroutineTransform.cmake
; ============================================================================

]])
    string(REPLACE "\${NUM_SUSPEND_POINTS}" "${NUM_SUSPEND_POINTS}" HEADER "${HEADER}")
    string(REPLACE "\${RESUME_LABELS}" "${RESUME_LABELS}" HEADER "${HEADER}")
    string(PREPEND TRANSFORMED_IR "${HEADER}")

    # Write output
    file(WRITE "${OUTPUT_FILE}" "${TRANSFORMED_IR}")

    message(STATUS "[KXS] Transformed ${INPUT_FILE}: ${NUM_SUSPEND_POINTS} suspend point(s)")
endfunction()

#[============================================================================[
  Public: Transform a single LLVM IR file

  kxs_transform_ir(<input.ll> <output.ll>)
#]============================================================================]
function(kxs_transform_ir INPUT_FILE OUTPUT_FILE)
    if(NOT EXISTS "${INPUT_FILE}")
        message(FATAL_ERROR "kxs_transform_ir: Input file does not exist: ${INPUT_FILE}")
    endif()

    _kxs_transform_ir_impl("${INPUT_FILE}" "${OUTPUT_FILE}")
endfunction()

#[============================================================================[
  Public: Enable coroutine transformation for a target

  kxs_enable_coroutine_transform(<target>)

  This sets up custom commands to:
  1. Compile .cpp to .ll (LLVM IR text)
  2. Transform the IR with suspend point lowering
  3. Compile transformed .ll to .o
#]============================================================================]
function(kxs_enable_coroutine_transform TARGET)
    if(NOT TARGET ${TARGET})
        message(FATAL_ERROR "kxs_enable_coroutine_transform: ${TARGET} is not a target")
    endif()

    # Get target sources
    get_target_property(TARGET_SOURCES ${TARGET} SOURCES)

    # Get this module's directory for the transform script
    set(KXS_MODULE_DIR "${CMAKE_CURRENT_FUNCTION_LIST_DIR}")
    set(KXS_TRANSFORM_SCRIPT "${KXS_MODULE_DIR}/kxs_transform_ir.cmake")

    # For each .cpp source, set up the transformation pipeline
    foreach(SOURCE ${TARGET_SOURCES})
        get_filename_component(SOURCE_EXT "${SOURCE}" EXT)
        if(SOURCE_EXT STREQUAL ".cpp" OR SOURCE_EXT STREQUAL ".cxx" OR SOURCE_EXT STREQUAL ".cc")
            get_filename_component(SOURCE_NAME "${SOURCE}" NAME_WE)
            get_filename_component(SOURCE_ABS "${SOURCE}" ABSOLUTE)

            set(LL_FILE "${CMAKE_CURRENT_BINARY_DIR}/${SOURCE_NAME}.ll")
            set(TRANSFORMED_LL "${CMAKE_CURRENT_BINARY_DIR}/${SOURCE_NAME}.kxs.ll")
            set(OBJ_FILE "${CMAKE_CURRENT_BINARY_DIR}/${SOURCE_NAME}.kxs.o")

            # Step 1: Compile to LLVM IR
            add_custom_command(
                OUTPUT "${LL_FILE}"
                COMMAND ${CMAKE_CXX_COMPILER}
                    -emit-llvm -S
                    "$<TARGET_PROPERTY:${TARGET},COMPILE_OPTIONS>"
                    "$<TARGET_PROPERTY:${TARGET},INCLUDE_DIRECTORIES>"
                    "${SOURCE_ABS}"
                    -o "${LL_FILE}"
                DEPENDS "${SOURCE_ABS}"
                COMMENT "[KXS] Emitting LLVM IR: ${SOURCE_NAME}.ll"
                VERBATIM
            )

            # Step 2: Transform IR (using cmake -P)
            add_custom_command(
                OUTPUT "${TRANSFORMED_LL}"
                COMMAND ${CMAKE_COMMAND}
                    -DINPUT_FILE="${LL_FILE}"
                    -DOUTPUT_FILE="${TRANSFORMED_LL}"
                    -P "${KXS_TRANSFORM_SCRIPT}"
                DEPENDS "${LL_FILE}" "${KXS_TRANSFORM_SCRIPT}"
                COMMENT "[KXS] Transforming: ${SOURCE_NAME}.ll -> ${SOURCE_NAME}.kxs.ll"
                VERBATIM
            )

            # Step 3: Compile transformed IR to object
            add_custom_command(
                OUTPUT "${OBJ_FILE}"
                COMMAND ${CMAKE_CXX_COMPILER}
                    -c "${TRANSFORMED_LL}"
                    -o "${OBJ_FILE}"
                DEPENDS "${TRANSFORMED_LL}"
                COMMENT "[KXS] Compiling transformed IR: ${SOURCE_NAME}.kxs.o"
                VERBATIM
            )

            # Add the object file to the target
            target_sources(${TARGET} PRIVATE "${OBJ_FILE}")
        endif()
    endforeach()

    message(STATUS "[KXS] Enabled coroutine transform for target: ${TARGET}")
endfunction()

#[============================================================================[
  Standalone script mode - for cmake -P invocation
#]============================================================================]
if(CMAKE_SCRIPT_MODE_FILE)
    if(DEFINED INPUT_FILE AND DEFINED OUTPUT_FILE)
        _kxs_transform_ir_impl("${INPUT_FILE}" "${OUTPUT_FILE}")
    endif()
endif()
