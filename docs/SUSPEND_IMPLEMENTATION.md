# Suspend Function Implementation in kotlinx.coroutines-cpp

**Version:** 3.0
**Last Updated:** December 13, 2025
**Status:** Active Implementation Guide

---

## Executive Summary

This document describes **how suspend functions work** in kotlinx.coroutines-cpp. The implementation uses **macros + computed goto** to generate LLVM IR that matches Kotlin/Native exactly (`indirectbr` + `blockaddress`).

### Current Implementation

**Production Approach:**
- **Macros** (`coroutine_begin`/`coroutine_yield`/`coroutine_end`) in `src/kotlinx/coroutines/dsl/Suspend.hpp`
- **Computed goto** with `void* _label` storing `&&label` addresses (default on GCC/Clang)
- **`__kxs_suspend_point(__LINE__)`** as an IR-visible marker for tooling
- **LLVM IR** compiles to `indirectbr` + `blockaddress` - exact Kotlin/Native parity

**IR Transformation (optional):**
- **kxs-inject** tool finds `__kxs_suspend_point()` calls in LLVM IR
- Performs liveness analysis and automatic spill generation
- Removes marker calls from final output

---

## Architecture Overview

### The Two Layers

```
+-------------------------------------------------------------+
|  1. User Code (Macros)                                       |
|     coroutine_begin(this)                                    |
|     coroutine_yield(this, delay(100, completion));           |
|     coroutine_end(this)                                      |
+-------------------------------------------------------------+
                            |
                            v
+-------------------------------------------------------------+
|  2. LLVM IR (Generated by clang)                             |
|     - blockaddress(@func, %resume_label)                     |
|     - indirectbr ptr %label, [label %resume0, ...]           |
|     - call void @__kxs_suspend_point(i32 N)  [marker]        |
+-------------------------------------------------------------+
                            |
                            v (optional)
+-------------------------------------------------------------+
|  3. kxs-inject (LLVM IR Transform)                           |
|     - Finds __kxs_suspend_point calls                        |
|     - Computes liveness, generates spills                    |
|     - Removes marker calls                                   |
+-------------------------------------------------------------+
```

### Design Goals

1. **Kotlin/Native IR Parity** - Generate identical LLVM IR (`indirectbr` + `blockaddress`)
2. **No External Plugin Required** - Works with stock clang/gcc
3. **IR-Visible Markers** - `__kxs_suspend_point()` survives to IR for tooling
4. **Portable Fallback** - Switch/case mode for MSVC

---

## Suspend Function ABI

### Signature Convention

All suspend functions follow this pattern:

```cpp
void* function_name(/* args */, std::shared_ptr<Continuation<void*>> completion)
```

**Return Value:**
- `COROUTINE_SUSPENDED` - Function suspended, will resume later
- `void*` - Boxed result (for non-Unit types), function completed immediately
- `nullptr` - Unit result, function completed immediately

### Suspension Marker

```cpp
// Defined in include/kotlinx/coroutines/intrinsics/Intrinsics.hpp
namespace kotlinx::coroutines::intrinsics {
    void* get_COROUTINE_SUSPENDED();  // Returns singleton marker
    bool is_coroutine_suspended(void* result);  // Checks if result == marker
}
```

---

## Writing Suspend Functions

### The Macro Approach (Production)

```cpp
#include <kotlinx/coroutines/dsl/Suspend.hpp>
#include <kotlinx/coroutines/ContinuationImpl.hpp>

class MyCoroutine : public ContinuationImpl {
public:
    void* _label = nullptr;  // blockaddress storage (computed goto)

    // Spilled variables (manual for now, kxs-inject automates later)
    int saved_value;

    explicit MyCoroutine(std::shared_ptr<Continuation<void*>> completion)
        : ContinuationImpl(std::move(completion)) {}

    void* invoke_suspend(Result<void*> result) override {
        coroutine_begin(this)

        saved_value = 42;

        // First suspend point
        coroutine_yield(this, delay(100, completion_));

        // After resumption
        std::cout << saved_value << std::endl;

        // Second suspend point
        coroutine_yield(this, yield(completion_));

        coroutine_end(this)
    }
};
```

### Key Elements

1. **`void* _label = nullptr`** - Stores blockaddress for `indirectbr` dispatch
2. **`coroutine_begin(this)`** - Entry dispatch: if nullptr goto start, else goto *label
3. **`coroutine_yield(this, expr)`** - Suspension point:
   - Stores `&&resume_label` in `_label`
   - Calls `__kxs_suspend_point(__LINE__)` (IR marker)
   - Executes expression
   - Returns `COROUTINE_SUSPENDED` if suspended
   - Resume label for continuation
4. **`coroutine_end(this)`** - Returns `nullptr` (Unit)

### Value-Producing Suspension

```cpp
void* invoke_suspend(Result<void*> result) override {
    void* fetched_data;

    coroutine_begin(this)

    // Suspend and capture result
    coroutine_yield_value(this, result, fetch_async(url, completion_), fetched_data);

    // fetched_data now contains the result
    process(fetched_data);

    coroutine_end(this)
}
```

---

## How It Compiles

### Source Code

```cpp
coroutine_yield(this, delay(100, completion_));
```

### Macro Expansion (Computed Goto Mode)

```cpp
do {
    (this)->_label = &&_kxs_resume_42;  // line 42
    ::__kxs_suspend_point(42);
    {
        auto _kxs_tmp = (delay(100, completion_));
        if (::kotlinx::coroutines::intrinsics::is_coroutine_suspended(_kxs_tmp))
            return _kxs_tmp;
    }
    goto _kxs_cont_42;
    _kxs_resume_42:
    (void)(result).get_or_throw();
    _kxs_cont_42:;
} while (0)
```

### Generated LLVM IR

```llvm
; Store blockaddress for resume
store ptr blockaddress(@_ZN11MyCoroutine14invoke_suspendE..., %resume42), ptr %label_ptr

; Call IR marker (kxs-inject finds this)
call void @__kxs_suspend_point(i32 42)

; Call delay
%tmp = call ptr @delay(i64 100, ptr %completion)

; Check if suspended
%is_suspended = call i1 @is_coroutine_suspended(ptr %tmp)
br i1 %is_suspended, label %return_suspended, label %continue

; Entry dispatch uses indirectbr
%saved_label = load ptr, ptr %label_ptr
%is_null = icmp eq ptr %saved_label, null
br i1 %is_null, label %start, label %dispatch

dispatch:
  indirectbr ptr %saved_label, [label %resume42, label %resume57, ...]
```

This is **identical** to what Kotlin/Native generates.

---

## Comparison: Kotlin/Native vs C++

### Kotlin Source

```kotlin
suspend fun example() {
    delay(100)
    println("after delay")
}
```

### Kotlin/Native Generated (Simplified)

```kotlin
class ExampleCoroutine : ContinuationImpl {
    var label: Any? = null  // blockaddress

    override fun invokeSuspend(result: Result<Any?>): Any? {
        when {
            label == null -> goto start
            else -> goto *label  // indirectbr
        }
        start:
        label = &&resume1
        val tmp = delay(100, this)
        if (tmp === COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED
        resume1:
        println("after delay")
        return Unit
    }
}
```

### C++ Equivalent

```cpp
class ExampleCoroutine : public ContinuationImpl {
    void* _label = nullptr;  // blockaddress

    void* invoke_suspend(Result<void*> result) override {
        coroutine_begin(this)  // if null goto start, else goto *label

        coroutine_yield(this, delay(100, completion_));  // stores &&resume, checks suspension

        std::cout << "after delay" << std::endl;

        coroutine_end(this)  // return nullptr
    }
};
```

### LLVM IR Comparison

| Aspect | Kotlin/Native | C++ (this impl) |
|--------|---------------|-----------------|
| Label storage | `void*` | `void* _label` |
| Label value | `blockaddress(@func, %bb)` | `blockaddress(@func, %bb)` |
| Entry dispatch | `indirectbr ptr %label, [...]` | `indirectbr ptr %label, [...]` |
| Suspend marker | `COROUTINE_SUSPENDED` singleton | `COROUTINE_SUSPENDED` singleton |
| Suspend check | `icmp eq ptr %tmp, @marker` | `icmp eq ptr %tmp, @marker` |

**Result:** Identical IR structure.

---

## IR Marker: `__kxs_suspend_point`

### Purpose

The `__kxs_suspend_point(int id)` function call serves as an **IR-visible marker** that:

1. **Survives compilation** - Unlike attributes, function calls appear in LLVM IR
2. **Carries metadata** - The `__LINE__` argument identifies each suspension point
3. **Enables tooling** - kxs-inject finds these for liveness analysis
4. **Gets removed** - kxs-inject or LTO eliminates the calls from final binary

### Declaration

```cpp
// In src/kotlinx/coroutines/dsl/Suspend.hpp
extern "C" void __kxs_suspend_point(int id);
```

### In IR

```llvm
call void @__kxs_suspend_point(i32 42)
call void @__kxs_suspend_point(i32 57)
```

### kxs-inject Processing

The `kxs-inject` tool (`src/kotlinx/coroutines/tools/kxs_inject/`) finds these calls and:

1. Computes liveness at each suspension point
2. Generates spill/restore code for live variables
3. Removes the marker calls from output IR

---

## Portable Fallback (MSVC)

When computed goto is unavailable (MSVC or `KXS_NO_COMPUTED_GOTO` defined), the macros use Duff's device:

```cpp
class MyCoroutine : public ContinuationImpl {
    int _label = 0;  // switch case number

    void* invoke_suspend(Result<void*> result) override {
        switch (_label) {
        case 0:
            (void)(result).get_or_throw();
            // code...
            _label = 42;
            ::__kxs_suspend_point(42);
            {
                auto _tmp = delay(100, completion_);
                if (is_coroutine_suspended(_tmp)) return _tmp;
            }
            goto _kxs_cont_42;
        case 42:
            (void)(result).get_or_throw();
            _kxs_cont_42:;
            // continue...
        }
        return nullptr;
    }
};
```

This is **semantically correct** but generates switch dispatch rather than `indirectbr`.

---

## Variable Spilling

### Current: Manual Spilling

Variables that must survive suspension are stored as class members:

```cpp
class MyCoroutine : public ContinuationImpl {
    void* _label = nullptr;

    // Spilled variables
    int count_spill;
    std::string name_spill;

    void* invoke_suspend(Result<void*> result) override {
        coroutine_begin(this)

        int count = 10;
        std::string name = "test";

        // Spill before suspension
        count_spill = count;
        name_spill = std::move(name);

        coroutine_yield(this, async_op(completion_));

        // Restore after resumption
        count = count_spill;
        name = std::move(name_spill);

        coroutine_end(this)
    }
};
```

### Future: Automatic Spilling (via kxs-inject)

The kxs-inject tool will:

1. Find `__kxs_suspend_point` markers in IR
2. Compute which variables are live across each point
3. Generate spill fields automatically
4. Insert save/restore code

This matches Kotlin/Native's `CoroutinesVarSpillingLowering.kt`.

---

## Build Integration

### Standard Build (No IR Transform)

```bash
cmake -B build
cmake --build build
```

Macros work out of the box. `__kxs_suspend_point` calls remain in binary (harmless no-ops).

### With kxs-inject (IR Transform)

```bash
cmake -B build -DKOTLINX_BUILD_KXS_INJECT=ON
cmake --build build

# Manual usage:
clang++ -S -emit-llvm -o file.ll file.cpp
./build/bin/kxs-inject file.ll -o file.transformed.ll
clang++ -c file.transformed.ll -o file.o
```

### CMake Integration

```cmake
# In cmake/Modules/kxs_transform_ir.cmake
include(kxs_transform_ir)
kxs_enable_suspend(my_target)
```

---

## Files Reference

### Core Implementation

| File | Purpose |
|------|---------|
| `src/kotlinx/coroutines/dsl/Suspend.hpp` | Macros: `coroutine_begin/yield/end` |
| `src/kotlinx/coroutines/ContinuationImpl.hpp` | Base class with `resume_with` loop |
| `src/kotlinx/coroutines/intrinsics/Intrinsics.hpp` | `COROUTINE_SUSPENDED` marker |
| `src/kotlinx/coroutines/Result.hpp` | Result wrapper for exceptions |

### IR Tooling

| File | Purpose |
|------|---------|
| `src/kotlinx/coroutines/tools/kxs_inject/kxs_inject.cpp` | LLVM IR transformer |
| `cmake/Modules/kxs_transform_ir.cmake` | CMake integration |

### Tests

| File | Purpose |
|------|---------|
| `src/tests/src/test_suspension_core.cpp` | Core macro tests |
| `src/tests/src/test_suspension_infrastructure.cpp` | Infrastructure tests |

---

## Changelog

**Version 3.0 (December 2025):**
- Macro-based approach with computed goto is now primary
- `__kxs_suspend_point()` as IR marker replaces `[[suspend]]` attribute
- Documented LLVM IR equivalence to Kotlin/Native
- kxs-inject tool for IR-level liveness analysis

**Version 2.0 (December 2025):**
- Clang plugin approach (deprecated)

---

*This is the authoritative suspend implementation guide for kotlinx.coroutines-cpp.*
